/**
 * This template file was generated by dynaTrace client.
 * The dynaTrace community portal can be found here: http://community.dynatrace.com/
 * For information how to publish a plugin please visit http://community.dynatrace.com/plugins/contribute/
 **/

package com.compuware.splunkintegration;

import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Iterator;

import com.dynatrace.diagnostics.pdk.Action;
import com.dynatrace.diagnostics.pdk.ActionEnvironment;
import com.dynatrace.diagnostics.pdk.Incident;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.PurePath;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.TaskEnvironment;
import com.dynatrace.diagnostics.pdk.Violation;

public class SplunkAction implements Action {

	// private static final Logger log =
	// Logger.getLogger(SplunkAction.class.getName());
	private HttpExporter httpExporter;

	/**
	 * Initializes the Action Plugin. This method is always called before
	 * <tt>execute</tt>. If the returned status is <tt>null</tt> or the status
	 * code is a non-success code then <tt>execute</tt> will not be called.
	 * 
	 * @param env
	 *            the configured <tt>ActionEnvironment</tt> for this Plugin;
	 *            <b>does not contain any incidents</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 * @throws Exception
	 */
	@Override
	public Status setup(ActionEnvironment env) throws Exception {
		httpExporter = new HttpExporter(env);
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Action Plugin to process incidents.
	 * 
	 * <p>
	 * This method is called at the scheduled intervals, but only if incidents
	 * occurred in the meantime. If the Plugin execution takes longer than the
	 * schedule interval, subsequent calls to
	 * {@link #execute(ActionEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 * 
	 * @param env
	 *            a <tt>ActionEnvironment</tt> object that contains the Plugin
	 *            configuration and incidents
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */
	@Override
	public Status execute(ActionEnvironment env) throws Exception {

		// this sample shows how to receive and act on incidents
		Collection<Incident> incidents = env.getIncidents();
		for (Incident incident : incidents) {

			if (incident == null || incident.getIncidentRule() == null)
				continue;

			String logAlertToSplunk = logAlertToSplunk(incident,
					env.getSystemProfileName());

			httpExporter.doExport(logAlertToSplunk.getBytes("UTF8"));
		}

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called either
	 * way if the Action setup/execution has failed or was successful.
	 * 
	 * @see Action#setup(ActionEnvironment)
	 */
	@Override
	public void teardown(ActionEnvironment env) throws Exception {
		// TODO
	}

	private String logAlertToSplunk(Incident incident, String systemProfileName) {
		StringBuilder sb = new StringBuilder("{ ");

		writeValue(sb, "dtIncidentName", incident.getIncidentRule().getName());
		writeValue(sb, "dtIncidentKey", incident.getKey().getUUID());
		writeValue(sb, "dtIncidentMessage", incident.getMessage());
		writeValue(sb, "dtIncidentDescription", incident.getIncidentRule().getDescription().replace("\n", "\\n"));
		writeValue(sb, "dtIncidentSeverity", incident.getSeverity());
		writeValue(sb, "dtIncidentServerName", incident.getServerName());
		writeValue(sb, "dtIncidentProfileName", systemProfileName);
		writeValue(sb, "dtIncidentServerName", incident.getServerName());
		String startTime = new SimpleDateFormat("yyyyMMddHHmmss")
				.format(incident.getStartTime().getTimestampInMs());
		writeValue(sb, "dtIncidentStartTime", startTime);
		writeValue(sb, "dtIncidentIsClosed", incident.isClosed());

		// incident.getKey()

		if (incident.isClosed()) {
			String time = new SimpleDateFormat("yyyyMMddHHmmss")
					.format(incident.getEndTime().getTimestampInMs());
			writeValue(sb, "dtIncidentEndTime", time);
			writeValue(sb, "dtIncidentDuration",
					String.valueOf(incident.getDuration()));
			writeValue(sb, "dtIncidentEventTime", time);
		} else {
			writeValue(sb, "dtIncidentEventTime", startTime);
		}

		if (incident.getPurePaths() != null
				&& !incident.getPurePaths().isEmpty()) {
			sb.append("\"dtIncidentPurePaths\" : [ ");
			Iterator<PurePath> it = incident.getPurePaths().iterator();
			while (it.hasNext()) {
				PurePath p = it.next();
				sb.append(p.toString());
				if (it.hasNext())
					sb.append(',');
			}
			sb.append("]");

		}
		sb.append("\"dtIncidentViolations\" : {");
		Iterator<Violation> iter = incident.getViolations().iterator();
		while (iter.hasNext()) {
			Violation violation = iter.next();

			Iterator<Violation.TriggerValue> itrat = violation
					.getTriggerValues().iterator();
			sb.append("\"" + violation.getViolatedMeasure().getName()
					+ "\" : [ ");
			while (itrat.hasNext()) {
				sb.append("\"" + itrat.next().getValue().getValue() + "\"");
				if (itrat.hasNext()) {
					sb.append(",");
				}
			}
			sb.append(" ]");
			if (iter.hasNext()) {
				sb.append(",");
			}
		}

		sb.append(" } }");

		return sb.toString();
	}

	private void writeValue(StringBuilder sb, String name, Object value) {
		sb.append("\"" + name + "\" : \"");
		sb.append(value);
		sb.append("\",");
	}
}
